<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>港湾AI自動検査システム v9_Morphing</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .scanner-line { position: absolute; width: 100%; height: 4px; background: #eab308; box-shadow: 0 0 15px #eab308; animation: scan 1.5s linear infinite; top: 0; opacity: 0; }
        @keyframes scan { 0% { top: 0; opacity: 0; } 20% { opacity: 1; } 80% { opacity: 1; } 100% { top: 100%; opacity: 0; } }
        .flash-effect { animation: flash 0.1s ease-out; }
        @keyframes flash { from { background: white; opacity: 0.8; } to { background: transparent; opacity: 0; } }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body class="bg-gray-900 h-screen flex flex-col overflow-hidden font-sans select-none">

    <div id="top-panel" class="h-[30%] bg-white flex flex-col relative z-20 shadow-lg transition-colors duration-500">
        <div class="absolute top-2 left-3 flex gap-2 z-30">
            <div id="ble-badge" class="px-2 py-0.5 rounded text-[10px] font-bold border flex items-center gap-1 bg-white/90 text-blue-600 border-blue-200 transition-all">
                <span class="w-1.5 h-1.5 rounded-full bg-blue-500 animate-pulse"></span> BLE接続：確立済み
            </div>
        </div>

        <div id="view-process" class="flex-1 flex flex-col items-center justify-center p-4">
            <div class="text-center mt-4">
                <h1 id="main-status" class="text-2xl font-black text-gray-800 tracking-tight">AI準備中...</h1>
                <p id="sub-status" class="text-xs text-gray-400 font-bold mt-1">カメラと解析モデルを起動しています</p>
            </div>
            <button id="btn-trigger" class="hidden mt-4 bg-slate-800 hover:bg-slate-700 text-white text-sm font-bold py-3 px-8 rounded-full shadow-lg active:scale-95 transition-transform flex items-center gap-2">
                CAN信号受信開始
            </button>
        </div>

        <div id="view-result" class="hidden absolute inset-0 flex flex-col items-center justify-center p-2 animate-fade-in">
            <div class="flex items-center gap-4">
                <span id="res-icon" class="text-5xl bg-white/20 rounded-full p-2">✅</span>
                <div class="text-left">
                    <div id="res-title" class="text-5xl font-black text-white tracking-tighter leading-none">OK</div>
                    <div id="res-desc" class="text-xs text-white/80 font-bold uppercase tracking-widest mt-1">状態正常</div>
                </div>
            </div>
            <button id="btn-confirm" class="mt-4 bg-white text-gray-900 font-black py-2 px-10 rounded-full shadow-lg active:scale-95 transition-transform text-sm border-b-4 border-gray-300 active:border-b-0 active:translate-y-0.5">
                確認完了（次へ）
            </button>
        </div>
    </div>

    <div class="h-[70%] relative bg-black overflow-hidden">
        <video id="webcam" class="absolute inset-0 w-full h-full object-cover opacity-80" autoplay playsinline muted></video>
        <canvas id="overlay" class="absolute inset-0 w-full h-full object-cover"></canvas>
        <div id="scan-bar" class="scanner-line"></div>
        <div id="shutter-overlay" class="absolute inset-0 pointer-events-none"></div>
        
        <div id="photo-container" class="absolute bottom-0 left-0 right-0 h-24 bg-gradient-to-t from-black/90 to-transparent p-2 pb-safe flex gap-2 overflow-x-auto items-end opacity-50 transition-opacity duration-300">
            <div class="text-[9px] text-gray-500 font-bold w-full text-center mb-2">自動連写された画像がここに表示されます</div>
        </div>
    </div>

    <script>
        const topPanel = document.getElementById('top-panel');
        const viewProcess = document.getElementById('view-process');
        const viewResult = document.getElementById('view-result');
        const mainStatus = document.getElementById('main-status');
        const subStatus = document.getElementById('sub-status');
        const btnTrigger = document.getElementById('btn-trigger');
        const btnConfirm = document.getElementById('btn-confirm');
        const bleBadge = document.getElementById('ble-badge');
        const resTitle = document.getElementById('res-title');
        const resIcon = document.getElementById('res-icon');
        const resDesc = document.getElementById('res-desc');
        const video = document.getElementById('webcam');
        const overlay = document.getElementById('overlay');
        const scanBar = document.getElementById('scan-bar');
        const shutterOverlay = document.getElementById('shutter-overlay');
        const photoContainer = document.getElementById('photo-container');

        let model, isModeActive = false, isCapturing = false;
        let audioCtx;
        
        // --- 【新機能】モーフィング用変数 ---
        // 現在の枠の状態 [x, y, width, height]
        let currentBox = { x: 0, y: 0, w: 0, h: 0, visible: false };
        // 中央の待機ポジション用
        let centerBox = { x: 0, y: 0, w: 200, h: 200 };

        function playFeedbackSound(type) {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);
            if (type === 'OK') {
                oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); oscillator.start(); oscillator.stop(audioCtx.currentTime + 0.2);
            } else if (type === 'NG') {
                oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); oscillator.start(); oscillator.stop(audioCtx.currentTime + 0.5);
                if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 500]);
            }
        }

        async function init() {
            try {
                model = await cocoSsd.load();
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    mainStatus.innerText = "信号待機中";
                    subStatus.innerText = "マキシブレーキ信号(J1939)の受信を待っています";
                    btnTrigger.classList.remove('hidden');
                    
                    // 初期位置を画面中央に設定
                    centerBox.x = (video.videoWidth - 200) / 2;
                    centerBox.y = (video.videoHeight - 200) / 2;
                    currentBox = { ...centerBox, visible: true }; // 初期状態は中央

                    detectFrame();
                };
            } catch (e) {
                mainStatus.innerText = "起動エラー";
                subStatus.innerText = "カメラの許可を確認してください";
            }
        }

        btnTrigger.addEventListener('click', () => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            isModeActive = true;
            btnTrigger.classList.add('hidden');
            mainStatus.innerText = "作業確認中";
            mainStatus.className = "text-3xl font-black text-blue-600 animate-pulse tracking-tight";
            subStatus.innerText = "対象をスキャン中：カメラを固定してください";
            bleBadge.className = "px-2 py-0.5 rounded text-[10px] font-bold border flex items-center gap-1 bg-gray-200 text-gray-500 border-gray-300";
            bleBadge.innerHTML = '<span class="w-1.5 h-1.5 rounded-full bg-gray-400"></span> BLE切断：スタンドアロン動作中';
            scanBar.style.opacity = "1";
            video.classList.remove('opacity-80');
            photoContainer.classList.remove('opacity-50');
            photoContainer.innerHTML = '';
        });

        // --- 【劇的進化】滑らかな追従ロジック ---
        async function detectFrame() {
            if (!video.videoWidth) { requestAnimationFrame(detectFrame); return; }
            
            overlay.width = video.videoWidth; 
            overlay.height = video.videoHeight;
            const ctx = overlay.getContext('2d');
            ctx.clearRect(0, 0, overlay.width, overlay.height);

            // 中央ポジションの更新（画面サイズが変わる可能性があるため）
            centerBox.x = (overlay.width - 200) / 2;
            centerBox.y = (overlay.height - 200) / 2;

            // 1. 連写中：最後にロックした位置で固定表示（赤枠）
            if (isCapturing) {
                drawBox(ctx, currentBox.x, currentBox.y, currentBox.w, currentBox.h, "#ef4444", 8, "CAPTURING...");
                requestAnimationFrame(detectFrame);
                return;
            }

            // 2. 探索モード
            const predictions = await model.detect(video);
            
            // 目標とする枠（ターゲット）を決める
            let target = { ...centerBox }; // デフォルトは中央の「待機枠」
            let hasTarget = false;
            let score = 0;
            let label = "SCANNING";

            if (predictions.length > 0) {
                // 最も確信度が高い物体をターゲットにする
                const best = predictions[0];
                // 閾値を下げて(0.25)、何かしらに反応しやすくする
                if (best.score > 0.25) {
                    target = { x: best.bbox[0], y: best.bbox[1], w: best.bbox[2], h: best.bbox[3] };
                    hasTarget = true;
                    score = best.score;
                    label = `${best.class.toUpperCase()} ${Math.round(score * 100)}%`;
                }
            }

            // 3. モーフィング処理（現在の枠をターゲットに向けて少しずつ動かす）
            // lerp (Linear Interpolation) 係数 0.2 で滑らかに追従
            const lerp = 0.2;
            currentBox.x += (target.x - currentBox.x) * lerp;
            currentBox.y += (target.y - currentBox.y) * lerp;
            currentBox.w += (target.w - currentBox.w) * lerp;
            currentBox.h += (target.h - currentBox.h) * lerp;

            // 4. 描画
            // ターゲット捕捉時は「青くて太い」、未捕捉時は「薄い水色で細い」
            const color = hasTarget ? "#2563eb" : "rgba(100, 200, 255, 0.4)";
            const lineWidth = hasTarget ? 4 : 2;
            
            // 待機中は点線、補足中は実線などの演出も可能だが、今回はシンプルに色と太さで表現
            drawBox(ctx, currentBox.x, currentBox.y, currentBox.w, currentBox.h, color, lineWidth, hasTarget ? label : null);

            // 5. トリガー判定（しっかりとらえた瞬間）
            // 枠がターゲットに十分近づき、かつ確信度が高い場合
            if (isModeActive && hasTarget && score > 0.6) {
                // 枠の動きが落ち着いているかチェック（急激に動いている最中は撮らない）
                const diff = Math.abs(target.x - currentBox.x) + Math.abs(target.w - currentBox.w);
                if (diff < 50) { // 差が小さい＝吸着した
                    isModeActive = false;
                    startBurstCapture();
                }
            }
            
            requestAnimationFrame(detectFrame);
        }

        // 枠描画のヘルパー関数
        function drawBox(ctx, x, y, w, h, color, lineWidth, text) {
            ctx.beginPath();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = color;
            ctx.rect(x, y, w, h);
            ctx.stroke();

            // 四隅の装飾（カッコいい枠にする）
            const cornerLen = 20;
            ctx.lineWidth = lineWidth + 2;
            ctx.beginPath();
            // 左上
            ctx.moveTo(x, y + cornerLen); ctx.lineTo(x, y); ctx.lineTo(x + cornerLen, y);
            // 右上
            ctx.moveTo(x + w - cornerLen, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + cornerLen);
            // 右下
            ctx.moveTo(x + w, y + h - cornerLen); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - cornerLen, y + h);
            // 左下
            ctx.moveTo(x + cornerLen, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - cornerLen);
            ctx.stroke();

            if (text) {
                ctx.fillStyle = color;
                ctx.font = "bold 14px sans-serif";
                ctx.fillText(text, x, y - 10);
            }
        }

        async function startBurstCapture() {
            isCapturing = true;
            mainStatus.innerText = "連写撮影中...";
            mainStatus.className = "text-3xl font-black text-red-500 tracking-tight";
            scanBar.style.animationDuration = "0.1s";
            for (let i = 0; i < 10; i++) {
                shutterOverlay.classList.remove('flash-effect');
                void shutterOverlay.offsetWidth;
                shutterOverlay.classList.add('flash-effect');
                addThumbnail(i);
                await new Promise(r => setTimeout(r, 100));
            }
            isCapturing = false;
            mainStatus.innerText = "AI判定中...";
            mainStatus.className = "text-3xl font-black text-gray-800 tracking-tight";
            setTimeout(showResult, 1000);
        }

        function addThumbnail(i) {
            const cvs = document.createElement('canvas');
            cvs.width = 160; cvs.height = 120;
            cvs.getContext('2d').drawImage(video, 0, 0, 160, 120);
            const img = document.createElement('img');
            img.src = cvs.toDataURL('image/jpeg');
            img.className = "h-full w-24 object-cover rounded border border-white/50 shadow-sm";
            photoContainer.insertBefore(img, photoContainer.firstChild);
        }

        function showResult() {
            viewProcess.classList.add('hidden');
            viewResult.classList.remove('hidden');
            const isOk = Math.random() > 0.3;
            if (isOk) {
                playFeedbackSound('OK');
                topPanel.className = "h-[30%] bg-green-500 flex flex-col relative z-20 shadow-lg transition-colors duration-500";
                resTitle.innerText = "OK"; resIcon.innerText = "✅"; resDesc.innerText = "状態正常";
            } else {
                playFeedbackSound('NG');
                topPanel.className = "h-[30%] bg-yellow-400 flex flex-col relative z-20 shadow-lg transition-colors duration-500 text-gray-900";
                resTitle.innerText = "NG"; resIcon.innerText = "⚠️"; resDesc.innerText = "異常あり：再確認してください";
            }
        }

        btnConfirm.addEventListener('click', () => {
            topPanel.className = "h-[30%] bg-white flex flex-col relative z-20 shadow-lg transition-colors duration-500";
            viewResult.classList.add('hidden'); viewProcess.classList.remove('hidden');
            bleBadge.className = "px-2 py-0.5 rounded text-[10px] font-bold border flex items-center gap-1 bg-white/90 text-blue-600 border-blue-200 transition-all";
            bleBadge.innerHTML = '<span class="w-1.5 h-1.5 rounded-full bg-blue-500 animate-pulse"></span> BLE接続：確立済み';
            mainStatus.innerText = "信号待機中"; mainStatus.className = "text-2xl font-black text-gray-800 tracking-tight";
            btnTrigger.classList.remove('hidden');
            video.classList.add('opacity-80');
            photoContainer.classList.add('opacity-50');
            photoContainer.innerHTML = '<div class="text-[9px] text-gray-500 font-bold w-full text-center mb-2">自動連写された画像がここに表示されます</div>';
            currentBox = { ...centerBox, visible: true }; // 枠を中央に戻す
        });

        init();
    </script>
</body>
</html>
